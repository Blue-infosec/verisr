% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/verisr.R
\name{fillVeris}
\alias{fillVeris}
\title{Recursively fill the data table list structure from buildVeris()}
\usage{
fillVeris(records, veris.built, filename = "not supplied", level = "root")
}
\arguments{
\item{records}{list. The incident as interpreted by nameveris()}

\item{veris.built}{list outputted by buildVeris.  This is used as
a template for the record.}

\item{filename}{character. record file name. Used for debug text.}

\item{level}{character. The column currently being filled.
defaults to 'root'.}
}
\value{
list of data tables of the structure from buidlVeris()
}
\description{
NOTE: list columns in empty list columns are not created as it
    would require that the intermediate list column have 
    data frames which would then have at least one row to contain
    the second empty list column.  This would potentially create
    extra samples.
    
    That said, the sample is the record itself which exists and
    so it may not matter for sample and in fact be better to have
    the all list columns contain data frames with a ddefault row
    down to the depth of the schema.  This would ensure that all
    endpoints of the schema exist in the record, potentially 
    making parsing easier. (Without it, the enumeration function
    will need to specifically catch lists that do not recurse to
    the depth of the schema.) (This may not actually be a 
    practical immediate problem as the only embedded lists of 
    lists are under 'sequence' which must exist.)
    
    Ultimately, how lists of objects are enumerated will decide
    the best approach.  (I.e. accurately counting assets of a 
    given type, for example 'People', under multiple sequence 
    steps per record across multiple records.)
}
